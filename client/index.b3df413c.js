import{S as s,i as e,s as a,c as t,e as n,a as o,b as r,d as l,f as c,g as h,h as i,u as f,j as u,k as d,t as $,l as p,m as E,n as m,o as v,p as g,q as A,r as k,v as w,w as D}from"./client.97fa62b7.js";function S(s){let e,a,E;const m=s[1].default,v=t(m,s,s[0],null);return{c(){e=n("header"),a=n("div"),v&&v.c(),this.h()},l(s){e=o(s,"HEADER",{class:!0});var t=r(e);a=o(t,"DIV",{class:!0});var n=r(a);v&&v.l(n),n.forEach(l),t.forEach(l),this.h()},h(){c(a,"class","container svelte-15el76v"),c(e,"class","wrapper svelte-15el76v")},m(s,t){h(s,e,t),i(e,a),v&&v.m(a,null),E=!0},p(s,[e]){v&&v.p&&(!E||1&e)&&f(v,m,s,s[0],E?d(m,s[0],e,null):u(s[0]),null)},i(s){E||($(v,s),E=!0)},o(s){p(v,s),E=!1},d(s){s&&l(e),v&&v.d(s)}}}function b(s,e,a){let{$$slots:t={},$$scope:n}=e;return s.$$set=s=>{"$$scope"in s&&a(0,n=s.$$scope)},[n,t]}class x extends s{constructor(s){super(),e(this,s,b,S,a,{})}}function y(s){let e,a;return{c(){e=n("h1"),a=v("Fair shuffles for $DEGEN holders"),this.h()},l(s){e=o(s,"H1",{class:!0});var t=r(e);a=k(t,"Fair shuffles for $DEGEN holders"),t.forEach(l),this.h()},h(){c(e,"class","banner-title")},m(s,t){h(s,e,t),i(e,a)},d(s){s&&l(e)}}}function G(s){let e,a,t,f,u,d;return e=new x({props:{$$slots:{default:[y]},$$scope:{ctx:s}}}),{c(){E(e.$$.fragment),a=m(),t=n("div"),f=n("p"),u=v("DEGEN Shuffles is a tool to pick random wallets of $degen holders. \n    Each shuffle is an ASA created on the Algorand blockchain. \n    These ASAs are used to store shuffle configurations \n    and keep an history of the winners over time."),this.h()},l(s){g(e.$$.fragment,s),a=A(s),t=o(s,"DIV",{class:!0});var n=r(t);f=o(n,"P",{});var c=r(f);u=k(c,"DEGEN Shuffles is a tool to pick random wallets of $degen holders. \n    Each shuffle is an ASA created on the Algorand blockchain. \n    These ASAs are used to store shuffle configurations \n    and keep an history of the winners over time."),c.forEach(l),n.forEach(l),this.h()},h(){c(t,"class","container svelte-mn8oyv")},m(s,n){w(e,s,n),h(s,a,n),h(s,t,n),i(t,f),i(f,u),d=!0},p(s,[a]){const t={};1&a&&(t.$$scope={dirty:a,ctx:s}),e.$set(t)},i(s){d||($(e.$$.fragment,s),d=!0)},o(s){p(e.$$.fragment,s),d=!1},d(s){D(e,s),s&&l(a),s&&l(t)}}}export default class extends s{constructor(s){super(),e(this,s,null,G,a,{})}}
