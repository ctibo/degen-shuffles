import{S as s,i as a,s as t,B as e,c as r,a as n,w as o,b as l,d as c,m as f,l as i,p as u,C as h,o as d,q as $,j as m,x as p,e as g,t as w,f as v,g as y,h as A,k as S,n as x,G as E,y as b,v as C,A as j,I}from"./client.3d44f302.js";import{S as N}from"./ShuffleConfigs.cfaada03.js";function B(s){let a,t;return{c(){a=g("h1"),t=w("New Shuffle"),this.h()},l(s){a=v(s,"H1",{class:!0});var e=y(a);t=A(e,"New Shuffle"),e.forEach(m),this.h()},h(){S(a,"class","page-title")},m(s,e){i(s,a,e),x(a,t)},d(s){s&&m(a)}}}function D(s){let a,t,e;return{c(){a=g("div"),t=g("p"),e=w("You must connect your wallet to create a shuffle."),this.h()},l(s){a=v(s,"DIV",{class:!0});var r=y(a);t=v(r,"P",{});var n=y(t);e=A(n,"You must connect your wallet to create a shuffle."),n.forEach(m),r.forEach(m),this.h()},h(){S(a,"class","container")},m(s,r){i(s,a,r),x(a,t),x(t,e)},p:C,i:C,o:C,d(s){s&&m(a)}}}function P(s){let a,t,e,o,h,p,E,b,C,B,D=j(s[0].currentAddress)+"";return C=new N({props:{mode:"create"}}),{c(){a=g("div"),t=g("p"),e=w("Creating a shuffle will add an ASA to your wallet ("),o=w(D),h=w("). "),p=g("br"),E=w(" \n      This asset will be used to store the shuffle configs and winners history."),b=n(),r(C.$$.fragment),this.h()},l(s){a=v(s,"DIV",{class:!0});var r=y(a);t=v(r,"P",{});var n=y(t);e=A(n,"Creating a shuffle will add an ASA to your wallet ("),o=A(n,D),h=A(n,"). "),p=v(n,"BR",{}),E=A(n," \n      This asset will be used to store the shuffle configs and winners history."),n.forEach(m),b=c(r),l(C.$$.fragment,r),r.forEach(m),this.h()},h(){S(a,"class","container")},m(s,r){i(s,a,r),x(a,t),x(t,e),x(t,o),x(t,h),x(t,p),x(t,E),x(a,b),f(C,a,null),B=!0},p(s,a){(!B||1&a)&&D!==(D=j(s[0].currentAddress)+"")&&I(o,D)},i(s){B||(d(C.$$.fragment,s),B=!0)},o(s){u(C.$$.fragment,s),B=!1},d(s){s&&m(a),$(C)}}}function T(s){let a,t,p,g,w,v;a=new e({props:{$$slots:{default:[B]},$$scope:{ctx:s}}});const y=[P,D],A=[];function S(s,a){return s[0].currentAddress?0:1}return p=S(s),g=A[p]=y[p](s),{c(){r(a.$$.fragment),t=n(),g.c(),w=o()},l(s){l(a.$$.fragment,s),t=c(s),g.l(s),w=o()},m(s,e){f(a,s,e),i(s,t,e),A[p].m(s,e),i(s,w,e),v=!0},p(s,[t]){const e={};2&t&&(e.$$scope={dirty:t,ctx:s}),a.$set(e);let r=p;p=S(s),p===r?A[p].p(s,t):(E(),u(A[r],1,1,(()=>{A[r]=null})),h(),g=A[p],g?g.p(s,t):(g=A[p]=y[p](s),g.c()),d(g,1),g.m(w.parentNode,w))},i(s){v||(d(a.$$.fragment,s),d(g),v=!0)},o(s){u(a.$$.fragment,s),u(g),v=!1},d(s){$(a,s),s&&m(t),A[p].d(s),s&&m(w)}}}function V(s,a,t){let e;return p(s,b,(s=>t(0,e=s))),[e]}export default class extends s{constructor(s){super(),a(this,s,V,T,t,{})}}
